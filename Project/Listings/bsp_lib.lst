C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BSP_LIB
OBJECT MODULE PLACED IN .\Objects\bsp_lib.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Src\bsp_lib.c OPTIMIZE(7,SPEED) BROWSE INCDIR(..\Inc) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\bsp_lib.lst) OBJECT(.\Objects\bsp_lib.obj)

line level    source

   1          #include "bsp_lib.h"
   2          #include "main.h"
   3          #include "intrins.h"
   4          #include "ir.h"
   5          #include "smg.h"
   6          #include "stdio.h"
   7          volatile u8 STA_P = 1; //速度默认是p1，最慢的速度
   8          volatile u8 STA_F = 1; //默认是F1模式
   9          volatile u8 STA_Mode = 0;
  10          volatile u8 STA_main = 0x00; //主要的状态标志位
  11          //第一位代表机器是否在工作
  12          //第二位代表是否开启了预约功能
  13          void delay_ms(unsigned int nms) //22.1184MHz
  14          {
  15   1          unsigned int cnt;
  16   1          unsigned char i, j;
  17   1          for (cnt = 0; cnt < nms; cnt++)
  18   1          {
  19   2              i = 29;
  20   2              j = 183;
  21   2              do
  22   2              {
  23   3                  while (--j)
  24   3                      ;
  25   3              } while (--i);
  26   2          }
  27   1      }
  28          void delay_us(unsigned int nus)
  29          {
  30   1          unsigned char i;
  31   1          unsigned int cnt;
  32   1          for (cnt = 0; cnt < nus; cnt++)
  33   1          {
  34   2              _nop_();
  35   2              i = 5;
  36   2              while (--i)
  37   2                  ;
  38   2          }
  39   1      }
  40          void delay_10us(unsigned int nus)
  41          {
  42   1          unsigned char i;
  43   1          unsigned int cnt;
  44   1          for (cnt = 0; cnt < nus; cnt++)
  45   1          {
  46   2              _nop_();
  47   2              _nop_();
  48   2              i = 71;
  49   2              while (--i)
  50   2                  ;
  51   2          }
  52   1      }
  53          void led_init(void)
  54          {
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 2   

  55   1          P0M1 = 0x00;
  56   1          P0M0 = 0x00;
  57   1          P1M1 = 0x00;
  58   1          P1M0 = 0x00;
  59   1          P2M1 = 0x00;
  60   1          P2M0 = 0x00;
  61   1          P3M1 = 0x00;
  62   1          P3M0 = 0x03;
  63   1          P4M1 = 0x00;
  64   1          P4M0 = 0x00;
  65   1          P5M1 = 0x00;
  66   1          P5M0 = 0xff;
  67   1          P6M1 = 0x00;
  68   1          P6M0 = 0x00;
  69   1          P7M1 = 0x00;
  70   1          P7M0 = 0x00;
  71   1          P1M0 = 0xff; //设置P1.0~P1.7为推挽输出模式
  72   1          P1M1 = 0x00;
  73   1      }
  74          void PCA_Init()
  75          {
  76   1          CCON = 0x00; //关闭PCA计数器，清除相关标志位
  77   1          CMOD = 0x0e; //PCA时钟源为系统时钟2分频  33.1776/2/1024=0.0162MHZ ==>16.2KHZ
  78   1          CL = 0x00;   //计数器清零
  79   1          CH = 0x00;
  80   1          /*------------------------PWM0部分-----------------------------*/
  81   1          CCAPM0 = 0x40;   //失能PCA模块0_PWM输出
  82   1          CCAP0L = 0X00;   //捕获比较寄存器低8位，比较值
  83   1          CCAP0H = 0X00;   //捕获比较寄存器高8位，重装值
  84   1          PCA_PWM0 = 0xC0; //10位PWM输出
  85   1          CCAPM0 = 0x42;   //使能PCA模块0_PWM输出
  86   1      
  87   1          /*------------------------PWM1部分-----------------------------*/
  88   1          CCAPM1 = 0x40;   //失能PCA模块1_PWM输出
  89   1          CCAP1L = 0X00;   //捕获比较寄存器低8位，比较值
  90   1          CCAP1H = 0X00;   //捕获比较寄存器高8位，重装值
  91   1          PCA_PWM1 = 0xC0; //10位PWM输出
  92   1          CCAPM1 = 0x42;   //使能PCA模块1_PWM输出
  93   1          /*------------------------PWM2部分-----------------------------*/
  94   1          CCAPM2 = 0x40;   //失能PCA模块2_PWM输出
  95   1          CCAP2L = 0X00;   //捕获比较寄存器低8位，比较值
  96   1          CCAP2H = 0X00;   //捕获比较寄存器高8位，重装值
  97   1          PCA_PWM2 = 0xC0; //10位PWM输出
  98   1          CCAPM2 = 0x42;   //使能PCA模块2_PWM输出
  99   1          CCON |= 1 << 6;  //启动计数器
 100   1      }
 101          //设置脉冲宽度
 102          void PWM0_Set_Duty(u16 Duty)
 103          {
 104   1          //注意：在更新 10 位 PWM 的重载值时，必须先写高两位 XCCAPnH[1:0]，再写低 8 位
             - CCAPnH[7:0]。
 105   1      
 106   1          CCAPM0 = 0x40;                  //失能PCA模块0_PWM输出
 107   1          PCA_PWM0 &= ~(3 << 4);          //清零重装值高2位
 108   1          PCA_PWM0 |= (Duty >> 4) & 0x30; //设置新的重装值高2位
 109   1          CCAP0H = Duty;                  //重装值低8位
 110   1          CCAPM0 = 0x42;                  //使能PCA模块0_PWM输出
 111   1      }
 112          //设置脉冲宽度
 113          void PWM1_Set_Duty(u16 Duty)
 114          {
 115   1          //注意：在更新 10 位 PWM 的重载值时，必须先写高两位 XCCAPnH[1:0]，再写低 8 位
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 3   

             - CCAPnH[7:0]。
 116   1      
 117   1          CCAPM1 = 0x40;                  //失能PCA模块1_PWM输出
 118   1          PCA_PWM1 &= ~(3 << 4);          //清零重装值高2位
 119   1          PCA_PWM1 |= (Duty >> 4) & 0x30; //设置新的重装值高2位
 120   1          CCAP1H = Duty;                  //重装值低8位
 121   1          CCAPM1 = 0x42;                  //使能PCA模块0_PWM输出
 122   1      }
 123          //设置脉冲宽度
 124          void PWM2_Set_Duty(u16 Duty)
 125          {
 126   1          //注意：在更新 10 位 PWM 的重载值时，必须先写高两位 XCCAPnH[1:0]，再写低 8 位
             - CCAPnH[7:0]。
 127   1          CCAPM2 = 0x40;                  //失能PCA模块2_PWM输出
 128   1          PCA_PWM2 &= ~(3 << 4);          //清零重装值高2位
 129   1          PCA_PWM2 |= (Duty >> 4) & 0x30; //设置新的重装值高2位
 130   1          CCAP2H = Duty;                  //重装值低8位
 131   1          CCAPM2 = 0x42;                  //使能PCA模块2_PWM输出
 132   1      }
 133          void motor_set(char num, int speed)
 134          {
 135   1          if (num == motor1)
 136   1          {
 137   2              if (speed > 0)
 138   2              {
 139   3                  PWM0_Set_Duty(1023 - speed);
 140   3                  PWM1_Set_Duty(1023);
 141   3              }
 142   2              else
 143   2              {
 144   3                  PWM0_Set_Duty(1023);
 145   3                  PWM1_Set_Duty(1023 - (-speed));
 146   3              }
 147   2          }
 148   1          else
 149   1          {
 150   2              PWM3 = 0;
 151   2              if (speed > 0)
 152   2              {
 153   3                  PWM2_Set_Duty(1023 - speed);
 154   3              }
 155   2              else
 156   2              {
 157   3                  PWM2_Set_Duty(1023 - (-speed));
 158   3              }
 159   2          }
 160   1      }
 161          #define FOSC 22118400L //系统频率
 162          #define fre 1000
 163          #define T0_TIM (65536 - (FOSC / 1 / fre))
 164          void Timer0Init(void) //1微秒@11.0592MHz
 165          {
 166   1          P5M0 = 0x00;
 167   1          P5M1 = 0x00;
 168   1          AUXR |= 0x80;       //定时器时钟1T模式
 169   1          TMOD &= 0xF0;       //设置定时器模式
 170   1          TL0 = T0_TIM % 256; //装载低8位计时值
 171   1          TH0 = T0_TIM / 256; //装载高8位
 172   1          TF0 = 0;            //清除TF0标志
 173   1          TR0 = 1;            //定时器0开始计时
 174   1          ET0 = 1;            //使能定时器中断
 175   1          EA = 1;
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 4   

 176   1      }
 177          void UartInit(void) //115200bps@22.1184MHz
 178          {
 179   1          SCON = 0x50;  //8位数据,可变波特率
 180   1          AUXR |= 0x40; //定时器时钟1T模式
 181   1          AUXR &= 0xFE; //串口1选择定时器1为波特率发生器
 182   1          TMOD &= 0x0F; //设置定时器模式
 183   1          TL1 = 0xD0;   //设置定时初始值
 184   1          TH1 = 0xFF;   //设置定时初始值
 185   1          ET1 = 0;      //禁止定时器%d中断
 186   1          TR1 = 1;      //定时器1开始计时
 187   1      }
 188          /*implemented for printf() */
 189          char putchar(char c)
 190          {
 191   1          SBUF = c;
 192   1          while (TI == 0)
 193   1              ;
 194   1          TI = 0;
 195   1          return c;
 196   1      }
 197          extern u8 gired_data[4];
 198          extern u8 key_table[17];
 199          volatile unsigned long tick_ms = 0;
 200          volatile unsigned long tick_s = 0;
 201          volatile char char1, char2, char3;
 202          volatile u8 smg_num = 0x00;
 203          volatile u8 key_flag = 29;
 204          void smg_display(u8 num, char s1, char s2, char s3);
 205          void timer0_ISR(void) interrupt 1 using 0
 206          {
 207   1          tick_ms++;
 208   1          if (tick_ms % 1000 == 0)
 209   1          {
 210   2              tick_s++;
 211   2              //  printf("%bd,%bu", flag_running, key_flag);
 212   2          }
 213   1          if (((STA_main & 0x80) == 0x80))
 214   1          {
 215   2              smg_num = 0x07;
 216   2              if (STA_Mode == mode1)
 217   2              {
 218   3                  char1 = 20;
 219   3              }
 220   2              else if (STA_Mode == mode2)
 221   2              {
 222   3                  char1 = 18;
 223   3              }
 224   2              else if (STA_Mode == mode3)
 225   2              {
 226   3                  char1 = 17;
 227   3              }
 228   2              char2 = 15;
 229   2              char3 = STA_F;
 230   2          }
 231   1          if ((STA_main & 0x40) == 0x40)
 232   1          {
 233   2              smg_num = 0x07;
 234   2              char1 = 8;
 235   2              char2 = 8;
 236   2              char3 = 8;
 237   2          }
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 5   

 238   1          smg_display(smg_num, char1, char2, char3);
 239   1      }
 240          void smg_display(u8 num, char s1, char s2, char s3)
 241          {
 242   1          if (num == 0)
 243   1          {
 244   2              display(0, 0);
 245   2          }
 246   1          else if (num == 1)
 247   1          {
 248   2              display(3, s3);
 249   2          }
 250   1          else if (num == 2)
 251   1          {
 252   2              display(2, s2);
 253   2          }
 254   1          else if (num == 4)
 255   1          {
 256   2              display(1, s1);
 257   2          }
 258   1          else if (num == 3)
 259   1          {
 260   2              if (tick_ms % 2 == 1)
 261   2              {
 262   3                  display(2, s2);
 263   3              }
 264   2              else if (tick_ms % 2 == 0)
 265   2              {
 266   3                  display(3, s3);
 267   3              }
 268   2          }
 269   1          else if (num == 5)
 270   1          {
 271   2              if (tick_ms % 2 == 1)
 272   2              {
 273   3                  display(1, s1);
 274   3              }
 275   2              else if (tick_ms % 2 == 0)
 276   2              {
 277   3                  display(3, s3);
 278   3              }
 279   2          }
 280   1          else if (num == 6)
 281   1          {
 282   2              if (tick_ms % 2 == 1)
 283   2              {
 284   3                  display(1, s1);
 285   3              }
 286   2              else if (tick_ms % 2 == 0)
 287   2              {
 288   3                  display(2, s2);
 289   3              }
 290   2          }
 291   1          else if (num == 7)
 292   1          {
 293   2              if (tick_ms % 3 == 1)
 294   2              {
 295   3                  display(1, s1);
 296   3              }
 297   2              else if (tick_ms % 3 == 2)
 298   2              {
 299   3                  display(2, s2);
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 6   

 300   3              }
 301   2              else if (tick_ms % 3 == 0)
 302   2              {
 303   3                  display(3, s3);
 304   3              }
 305   2          }
 306   1      }
 307          void display_user(u8 num, char s1, char s2, char s3)
 308          {
 309   1          smg_num = num;
 310   1          char1 = s1;
 311   1          char2 = s2;
 312   1          char3 = s3;
 313   1      }
 314          void zhendong_mode(void)
 315          {
 316   1          static u16 i;
 317   1          char tick_ms_temp, flag = 0;
 318   1          i++;
 319   1          tick_ms_temp = tick_ms;
 320   1          while ((tick_ms - tick_ms_temp) < 1)
 321   1              ;
 322   1          if (i % 500 == 0)
 323   1          {
 324   2              flag = !flag;
 325   2              if (flag)
 326   2              {
 327   3                  motor_set(2, STA_P * 100);
 328   3              }
 329   2              else
 330   2              {
 331   3                  motor_set(2, 0);
 332   3              }
 333   2          }
 334   1      }
 335          void qiaoda_mode(void)
 336          {
 337   1          static u16 i;
 338   1          char tick_ms_temp, flag = 0;
 339   1          i++;
 340   1          tick_ms_temp = tick_ms;
 341   1          while ((tick_ms - tick_ms_temp) < 1)
 342   1              ;
 343   1          if (i % 500 == 0)
 344   1          {
 345   2              flag = !flag;
 346   2              if (flag)
 347   2              {
 348   3                  motor_set(2, STA_P * 100);
 349   3              }
 350   2              else
 351   2              {
 352   3                  motor_set(2, 0);
 353   3              }
 354   2          }
 355   1      }
 356          void hunhe_mode(void)
 357          {
 358   1          static u16 i;
 359   1          char tick_ms_temp, flag1 = 0, flag2 = 0;
 360   1          i++;
 361   1          tick_ms_temp = tick_ms;
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/11/2021 10:19:16 PAGE 7   

 362   1          while ((tick_ms - tick_ms_temp) < 1)
 363   1              ;
 364   1          if (i % 1000 == 0)
 365   1          {
 366   2              flag1 = !flag1;
 367   2              if (flag1)
 368   2              {
 369   3                  motor_set(1, STA_P * 100);
 370   3              }
 371   2              else
 372   2              {
 373   3                  motor_set(1, -STA_P * 100);
 374   3              }
 375   2          }
 376   1          if (i % 500 == 0)
 377   1          {
 378   2              flag2 = !flag2;
 379   2              if (flag2)
 380   2              {
 381   3                  motor_set(2, STA_P * 100);
 382   3              }
 383   2              else
 384   2              {
 385   3                  motor_set(2, 0);
 386   3              }
 387   2          }
 388   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1427    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     23      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
