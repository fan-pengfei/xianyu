C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE BSP_LIB
OBJECT MODULE PLACED IN .\Objects\bsp_lib.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE ..\Src\bsp_lib.c OPTIMIZE(7,SPEED) BROWSE INCDIR(..\Inc) DEBUG OBJECTEXT
                    -END PRINT(.\Listings\bsp_lib.lst) OBJECT(.\Objects\bsp_lib.obj)

line level    source

   1          #include "bsp_lib.h"
   2          #include "main.h"
   3          #include "intrins.h"
   4          #include "ir.h"
   5          #include "smg.h"
   6          #include "stdio.h"
   7          #include <stdarg.h>
   8          volatile u8 STA_P = 1; //速度默认是p1，最慢的速度
   9          volatile u8 STA_F = 1; //默认是F1模式
  10          volatile u8 STA_Mode = 0;
  11          volatile u8 STA_main = 0x00; //主要的状态标志位
  12          //第一位代表机器是否在工作
  13          //第二位代表是否锁定键盘
  14          //第三位代表是否选择了预约
  15          //第四位代表是否正在预约定时中
  16          //第五位代表是否在关机状态中
  17          //第六位代表是否第一次上电 1是否
  18          void delay_ms(unsigned int nms) //22.1184MHz
  19          {
  20   1          unsigned int cnt;
  21   1          unsigned char i, j;
  22   1          for (cnt = 0; cnt < nms; cnt++)
  23   1          {
  24   2              i = 29;
  25   2              j = 183;
  26   2              do
  27   2              {
  28   3                  while (--j)
  29   3                      ;
  30   3              } while (--i);
  31   2          }
  32   1      }
  33          void delay_us(unsigned int nus)
  34          {
  35   1          unsigned char i;
  36   1          unsigned int cnt;
  37   1          for (cnt = 0; cnt < nus; cnt++)
  38   1          {
  39   2              _nop_();
  40   2              i = 5;
  41   2              while (--i)
  42   2                  ;
  43   2          }
  44   1      }
  45          void delay_10us(unsigned int nus)
  46          {
  47   1          unsigned char i;
  48   1          unsigned int cnt;
  49   1          for (cnt = 0; cnt < nus; cnt++)
  50   1          {
  51   2              _nop_();
  52   2              _nop_();
  53   2              i = 71;
  54   2              while (--i)
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 2   

  55   2                  ;
  56   2          }
  57   1      }
  58          void led_init(void)
  59          {
  60   1          P0M1 = 0x00;
  61   1          P0M0 = 0x00;
  62   1          P1M1 = 0x00;
  63   1          P1M0 = 0x00;
  64   1          P2M1 = 0x00;
  65   1          P2M0 = 0x00;
  66   1          P3M1 = 0x00;
  67   1          P3M0 = 0xfb;
  68   1          P4M1 = 0x00;
  69   1          P4M0 = 0x00;
  70   1          P5M1 = 0x00;
  71   1          P5M0 = 0xff;
  72   1          P6M1 = 0x00;
  73   1          P6M0 = 0x00;
  74   1          P7M1 = 0x00;
  75   1          P7M0 = 0x00;
  76   1          P1M0 = 0xff; //设置P1.0~P1.7为推挽输出模式
  77   1          P1M1 = 0x00;
  78   1      }
  79          void PCA_Init()
  80          {
  81   1          CCON = 0x00; //关闭PCA计数器，清除相关标志位
  82   1          CMOD = 0x0e; //PCA时钟源为系统时钟2分频  33.1776/2/1024=0.0162MHZ ==>16.2KHZ
  83   1          CL = 0x00;   //计数器清零
  84   1          CH = 0x00;
  85   1          /*------------------------PWM0部分-----------------------------*/
  86   1          CCAPM0 = 0x40;   //失能PCA模块0_PWM输出
  87   1          CCAP0L = 0X00;   //捕获比较寄存器低8位，比较值
  88   1          CCAP0H = 0X00;   //捕获比较寄存器高8位，重装值
  89   1          PCA_PWM0 = 0xC0; //10位PWM输出
  90   1          CCAPM0 = 0x42;   //使能PCA模块0_PWM输出
  91   1      
  92   1          /*------------------------PWM1部分-----------------------------*/
  93   1          CCAPM1 = 0x40;   //失能PCA模块1_PWM输出
  94   1          CCAP1L = 0X00;   //捕获比较寄存器低8位，比较值
  95   1          CCAP1H = 0X00;   //捕获比较寄存器高8位，重装值
  96   1          PCA_PWM1 = 0xC0; //10位PWM输出
  97   1          CCAPM1 = 0x42;   //使能PCA模块1_PWM输出
  98   1          /*------------------------PWM2部分-----------------------------*/
  99   1          CCAPM2 = 0x40;   //失能PCA模块2_PWM输出
 100   1          CCAP2L = 0X00;   //捕获比较寄存器低8位，比较值
 101   1          CCAP2H = 0X00;   //捕获比较寄存器高8位，重装值
 102   1          PCA_PWM2 = 0xC0; //10位PWM输出
 103   1          CCAPM2 = 0x42;   //使能PCA模块2_PWM输出
 104   1          CCON |= 1 << 6;  //启动计数器
 105   1      }
 106          //设置脉冲宽度
 107          void PWM0_Set_Duty(u16 Duty)
 108          {
 109   1          //注意：在更新 10 位 PWM 的重载值时，必须先写高两位 XCCAPnH[1:0]，再写低 8 位
             - CCAPnH[7:0]。
 110   1      
 111   1          CCAPM0 = 0x40;                  //失能PCA模块0_PWM输出
 112   1          PCA_PWM0 &= ~(3 << 4);          //清零重装值高2位
 113   1          PCA_PWM0 |= (Duty >> 4) & 0x30; //设置新的重装值高2位
 114   1          CCAP0H = Duty;                  //重装值低8位
 115   1          CCAPM0 = 0x42;                  //使能PCA模块0_PWM输出
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 3   

 116   1      }
 117          //设置脉冲宽度
 118          void PWM1_Set_Duty(u16 Duty)
 119          {
 120   1          //注意：在更新 10 位 PWM 的重载值时，必须先写高两位 XCCAPnH[1:0]，再写低 8 位
             - CCAPnH[7:0]。
 121   1          CCAPM1 = 0x40;                  //失能PCA模块1_PWM输出
 122   1          PCA_PWM1 &= ~(3 << 4);          //清零重装值高2位
 123   1          PCA_PWM1 |= (Duty >> 4) & 0x30; //设置新的重装值高2位
 124   1          CCAP1H = Duty;                  //重装值低8位
 125   1          CCAPM1 = 0x42;                  //使能PCA模块0_PWM输出
 126   1      }
 127          //设置脉冲宽度
 128          void PWM2_Set_Duty(u16 Duty)
 129          {
 130   1          //注意：在更新 10 位 PWM 的重载值时，必须先写高两位 XCCAPnH[1:0]，再写低 8 位
             - CCAPnH[7:0]。
 131   1          CCAPM2 = 0x40;                  //失能PCA模块2_PWM输出
 132   1          PCA_PWM2 &= ~(3 << 4);          //清零重装值高2位
 133   1          PCA_PWM2 |= (Duty >> 4) & 0x30; //设置新的重装值高2位
 134   1          CCAP2H = Duty;                  //重装值低8位
 135   1          CCAPM2 = 0x42;                  //使能PCA模块2_PWM输出
 136   1      }
 137          void motor_set(char num, int speed)
 138          {
 139   1          if (num == motor1)
 140   1          {
 141   2              if (speed > 0)
 142   2              {
 143   3                  PWM0_Set_Duty(1023 - speed);
 144   3                  PWM1_Set_Duty(1023);
 145   3              }
 146   2              else
 147   2              {
 148   3                  PWM0_Set_Duty(1023);
 149   3                  PWM1_Set_Duty(1023 + speed);
 150   3              }
 151   2          }
 152   1          else
 153   1          {
 154   2              PWM3 = 0;
 155   2              if (speed > 0)
 156   2              {
 157   3                  PWM2_Set_Duty((unsigned int)1023 - (unsigned int)speed);
 158   3              }
 159   2              else
 160   2              {
 161   3                  PWM2_Set_Duty((unsigned int)1023 - (unsigned int)(-speed));
 162   3              }
 163   2          }
 164   1      }
 165          void Timer0Init(void) //1微秒@11.0592MHz
 166          {
 167   1          P5M0 = 0x00;
 168   1          P5M1 = 0x00;
 169   1          AUXR |= 0x80; //定时器时钟1T模式
 170   1          TMOD &= 0xF0; //设置定时器模式
 171   1          TL0 = 0xCD;   //设置定时初始值
 172   1          TH0 = 0xD4;   //设置定时初始值
 173   1          TF0 = 0;      //清除TF0标志
 174   1          TR0 = 1;      //定时器0开始计时
 175   1          ET0 = 1;      //使能定时器中断
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 4   

 176   1          EA = 1;
 177   1      }
 178          void UartInit(void) //115200bps@22.1184MHz
 179          {
 180   1          SCON = 0x50;  //8位数据,可变波特率
 181   1          AUXR |= 0x40; //定时器时钟1T模式
 182   1          AUXR &= 0xFE; //串口1选择定时器1为波特率发生器
 183   1          TMOD &= 0x0F; //设置定时器模式
 184   1          TL1 = 0xD0;   //设置定时初始值
 185   1          TH1 = 0xFF;   //设置定时初始值
 186   1          ET1 = 0;      //禁止定时器%d中断
 187   1          TR1 = 1;      //定时器1开始计时
 188   1      }
 189          /*implemented for printf() */
 190          char putchar(char c)
 191          {
 192   1          SBUF = c;
 193   1          while (TI == 0)
 194   1              ;
 195   1          TI = 0;
 196   1          return c;
 197   1      }
 198          extern u8 gired_data[4];
 199          extern u8 key_table[17];
 200          volatile unsigned long tick_ms = 0;
 201          volatile unsigned long tick_s = 0;
 202          volatile unsigned int tick_min = 0;
 203          volatile char char1, char2, char3;
 204          volatile u8 smg_num = 0x00;
 205          volatile u8 key_flag = 29;
 206          volatile unsigned long cnt_ms = 0;
 207          volatile unsigned long cnt_s = 0;
 208          volatile unsigned long cnt_min = 0;
 209          volatile unsigned long cnt_hour = 0;
 210          volatile unsigned char tim_yuyue = 0;
 211          volatile unsigned long cnt_s_2 = 0;
 212          void smg_display(u8 num, char s1, char s2, char s3);
 213          void timer0_ISR(void) interrupt 1 using 0
 214          {
 215   1          static char flag_yuyue = 0;
 216   1          if (((STA_main & 0x10) == 0x10) && (flag_yuyue == 0)) //一旦开始预约定时状态
 217   1          {
 218   2              flag_yuyue++;
 219   2          }
 220   1          if ((cnt_hour >= tim_yuyue) && ((STA_main & 0x10) == 0x10)) //预约计时中，且到达预约时间
 221   1          {
 222   2              flag_yuyue = 0;
 223   2              tim_yuyue = 1;
 224   2              STA_main = STA_main & 0xdf; //清除开始计时状态
 225   2              STA_main = STA_main & 0xbf; //清除预约状态
 226   2              STA_main = 0x80;
 227   2          }
 228   1          tick_ms++;
 229   1          if (tick_ms % 2000 == 0)
 230   1          {
 231   2              putchar('S');
 232   2              putchar((cnt_s / 10) + '0');
 233   2              putchar((cnt_s % 10) + '0');
 234   2              putchar(10);
 235   2              putchar(13);
 236   2              putchar('M');
 237   2              putchar((cnt_min / 10) + '0');
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 5   

 238   2              putchar((cnt_min % 10) + '0');
 239   2              putchar(10);
 240   2              putchar(13);
 241   2              tick_s++;
 242   2              cnt_s++; //必须用一个新的变量保存定时时间
 243   2              cnt_s_2++;
 244   2              if (cnt_s % 60 == 0)
 245   2              {
 246   3                  cnt_min++;
 247   3                  if (cnt_s % 3600 == 0)
 248   3                  {
 249   4                      cnt_hour++;
 250   4                  }
 251   3              }
 252   2          }
 253   1          if (((STA_main & 0x80) == 0x80))
 254   1          {
 255   2              smg_num = 0x07;
 256   2              if (STA_Mode == mode1)
 257   2              {
 258   3                  char1 = 20;
 259   3              }
 260   2              else if (STA_Mode == mode2)
 261   2              {
 262   3                  char1 = 18;
 263   3              }
 264   2              else if (STA_Mode == mode3)
 265   2              {
 266   3                  char1 = 17;
 267   3              }
 268   2              char2 = 15;
 269   2              char3 = STA_F;
 270   2          }
 271   1          else if ((STA_main & 0x20) == 0x20)
 272   1          {
 273   2              smg_num = 0x07;
 274   2              char1 = 14;
 275   2              char2 = 0;
 276   2              char3 = tim_yuyue - cnt_hour;
 277   2          }
 278   1          else if ((STA_main & 0x10) == 0x10)
 279   1          {
 280   2              smg_num = 0x07;
 281   2              char1 = 14;
 282   2              char2 = 0;
 283   2              char3 = tim_yuyue - cnt_hour;
 284   2          }
 285   1          if ((STA_main & 0x40) == 0x40)
 286   1          {
 287   2              smg_num = 0x07;
 288   2              char1 = 8;
 289   2              char2 = 8;
 290   2              char3 = 8;
 291   2          }
 292   1          smg_display(smg_num, char1, char2, char3);
 293   1      }
 294          void smg_display(u8 num, char s1, char s2, char s3)
 295          {
 296   1          if (num == 0)
 297   1          {
 298   2              display(0, 0);
 299   2          }
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 6   

 300   1          else if (num == 1)
 301   1          {
 302   2              display(3, s3);
 303   2          }
 304   1          else if (num == 2)
 305   1          {
 306   2              display(2, s2);
 307   2          }
 308   1          else if (num == 4)
 309   1          {
 310   2              display(1, s1);
 311   2          }
 312   1          else if (num == 3)
 313   1          {
 314   2              if (tick_ms % 2 == 1)
 315   2              {
 316   3                  display(2, s2);
 317   3              }
 318   2              else if (tick_ms % 2 == 0)
 319   2              {
 320   3                  display(3, s3);
 321   3              }
 322   2          }
 323   1          else if (num == 5)
 324   1          {
 325   2              if (tick_ms % 2 == 1)
 326   2              {
 327   3                  display(1, s1);
 328   3              }
 329   2              else if (tick_ms % 2 == 0)
 330   2              {
 331   3                  display(3, s3);
 332   3              }
 333   2          }
 334   1          else if (num == 6)
 335   1          {
 336   2              if (tick_ms % 2 == 1)
 337   2              {
 338   3                  display(1, s1);
 339   3              }
 340   2              else if (tick_ms % 2 == 0)
 341   2              {
 342   3                  display(2, s2);
 343   3              }
 344   2          }
 345   1          else if (num == 7)
 346   1          {
 347   2              if (tick_ms % 3 == 1)
 348   2              {
 349   3                  display(1, s1);
 350   3              }
 351   2              else if (tick_ms % 3 == 2)
 352   2              {
 353   3                  display(2, s2);
 354   3              }
 355   2              else if (tick_ms % 3 == 0)
 356   2              {
 357   3                  display(3, s3);
 358   3              }
 359   2          }
 360   1      }
 361          void display_user(u8 num, char s1, char s2, char s3)
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 7   

 362          {
 363   1          smg_num = num;
 364   1          char1 = s1;
 365   1          char2 = s2;
 366   1          char3 = s3;
 367   1      }
 368          void zhendong_mode(void)
 369          {
 370   1      
 371   1          static u16 i;
 372   1          u16 j = 8000;
 373   1          static char flag = 1;
 374   1          i++;
 375   1          while (j--)
 376   1              ;
 377   1          // delay_ms(1);
 378   1          motor_set(motor1, 0);
 379   1          if (i == 500)
 380   1          {
 381   2              i = 0;
 382   2              flag = !flag;
 383   2              if (flag)
 384   2              {
 385   3                  motor_set(motor2, 324 + STA_P * 50);
 386   3              }
 387   2              else
 388   2              {
 389   3                  motor_set(motor2, 0);
 390   3              }
 391   2          }
 392   1      }
 393          u16 speed_motor2[9] = {1300, 1200, 1100, 900, 800, 600, 500, 400, 300};
 394          void qiaoda_mode(void)
 395          {
 396   1          static u16 i = 0;
 397   1          static char flag = 1;
 398   1          u16 j = 8000;
 399   1          i++;
 400   1          while (j--)
 401   1              ;
 402   1          // delay_ms
 403   1          motor_set(motor2, 0);
 404   1          if (i >= speed_motor2[(int)(STA_P - 1)])
 405   1          {
 406   2              i = 0;
 407   2              flag = !flag;
 408   2              if (flag)
 409   2              {
 410   3                  motor_set(motor1, STA_P * 100);
 411   3              }
 412   2              else
 413   2              {
 414   3                  motor_set(motor1, -(int)(STA_P * 100)); //无符号有符号混用会出问题
 415   3              }
 416   2          }
 417   1      }
 418          void hunhe_mode(void)
 419          {
 420   1          static u16 i = 0, k = 0;
 421   1          u16 j = 8000;
 422   1          static char flag1 = 0, flag2 = 0;
 423   1          i++;
C51 COMPILER V9.60.0.0   BSP_LIB                                                           09/13/2021 13:35:05 PAGE 8   

 424   1          k++;
 425   1          while (j--)
 426   1              ;
 427   1          if (i >= speed_motor2[(int)(STA_P - 1)])
 428   1          {
 429   2              i = 0;
 430   2              flag1 = !flag1;
 431   2              if (flag1)
 432   2              {
 433   3                  motor_set(motor1, STA_P * 100);
 434   3              }
 435   2              else
 436   2              {
 437   3                  motor_set(motor1, -(int)STA_P * 100);
 438   3              }
 439   2          }
 440   1          if (k == 500)
 441   1          {
 442   2              k = 0;
 443   2              flag2 = !flag2;
 444   2              if (flag2)
 445   2              {
 446   3                  motor_set(motor2, STA_P * 100);
 447   3              }
 448   2              else
 449   2              {
 450   3                  motor_set(motor2, 0);
 451   3              }
 452   2          }
 453   1      }
 454          void stop_mode(void)
 455          {
 456   1          motor_set(motor1, 0);
 457   1          motor_set(motor2, 0);
 458   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1826    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     71       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
